#-
# ==========================================================================
# Copyright (C) 2018 - 2020 Ocean Cloud Rendering. and/or its licensors.  All
# rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to RenderShare. ("RenderShare") and/or its
# licensors, which is protected by Canadian federal copyright
# law and by international treaties.
#
# The Data is provided for use exclusively by You. You have the right
# to use, and incorporate this Data into other products for
# purposes authorized by the RenderShare software license agreement,
# without fee.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
# RenderShare DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED
# WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF
# NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
# PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR
# TRADE PRACTICE. IN NO EVENT WILL RenderShare AND/OR ITS LICENSORS
# BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF RenderShare
# AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY
# OR PROBABILITY OF SUCH DAMAGES.
#
# ==========================================================================
#+

import clr
import os
import sys
import time
import json
import shutil
import datetime
import subprocess

from System import *
from System.Diagnostics import *
from System.IO import *

from Deadline.Plugins import *
from Deadline.Scripting import *

######################################################################
## This is the function that Deadline calls to get an instance of the
## main DeadlinePlugin class.
######################################################################

def GetDeadlinePlugin():
    return RB_KeyshotPlugin()

def CleanupDeadlinePlugin( deadlinePlugin ):
    deadlinePlugin.Cleanup()


######################################################################
## This is the main DeadlinePlugin class for the KeyShot plugin.
######################################################################

class RB_KeyshotPlugin(DeadlinePlugin):

    d_render_mode = {"0": "custom_control",
                     "1": "maximum_time",
                     "2": "maximum_samples"}

    l_req_transfer = ["exr", "psd", "tif"]
    s_random = str(time.time()).split('.')[0]
    b_output_transfer = False
    d_transfer_data = {"src_path": str(),
                       "out_path": str()}
    s_job_name = str()

    def __init__(self):

        self.InitializeProcessCallback  += self.InitializeProcess
        self.RenderExecutableCallback   += self.RenderExecutable
        self.RenderArgumentCallback     += self.RenderArgument
        self.PreRenderTasksCallback     += self.PreRenderTasks
        self.PostRenderTasksCallback    += self.PostRenderTasks
        self.infoFilePath = str()

    def TempCleanup(self):
        s_temp_path = r"C:\Temp"
        self.LogInfo("Default Temp Folder Dir : " + s_temp_path)
        self.LogInfo("Running TempCleanup System")

        if not s_temp_path:
            self.LogWarning("temp directory not exists")
            return

        for dir in os.walk(s_temp_path):
            if dir[0] != s_temp_path:
                set_dir = dir[0]
                last_modified = datetime.datetime.fromtimestamp(os.path.getmtime(set_dir))
                now_time = datetime.datetime.now()
                delta_time = now_time - last_modified

                if int(delta_time.days) >= 3:
                    try:
                        shutil.rmtree(set_dir, ignore_errors=True)
                    except OSError:
                        self.LogWarning("Directory : %s could not be deleted" % set_dir)
                    if not os.path.exists(set_dir):
                        self.LogInfo("[Deleted] Time Passed : %s >> Directory : %s " % (delta_time, set_dir))


    def RenderTempSetup(self):

        render_dir = str(os.path.join(os.environ['HOMEPATH'], 'Desktop', 'TempRender')).replace("\\", "/")
        if not os.path.exists(render_dir):
            try:
                os.mkdir(render_dir)
            except OSError:
                self.LogWarning("Creation of the directory %s failed" % render_dir)
            else:
                self.LogInfo("Successfully created the directory %s " % render_dir)

        return render_dir

    def Cleanup(self):

        for stdoutHandler in self.StdoutHandlers:
            del stdoutHandler.HandleCallback

        del self.InitializeProcessCallback
        del self.RenderExecutableCallback
        del self.RenderArgumentCallback
        del self.PreRenderTasksCallback
        del self.PostRenderTasksCallback

    def InitializeProcess(self):

        self.PluginType = PluginType.Simple
        self.StdoutHandling = True


    def RenderExecutable(self):
        version = self.GetPluginInfoEntryWithDefault("version","7")

        keyshotExeList = self.GetConfigEntry("RenderExecutable%s" % version)
        keyshotExe = FileUtils.SearchFileList(keyshotExeList)
        if (keyshotExe == ""):
            self.FailRender("KeyShot "
                            + version
                            + " render executable was not found in the semicolon separated list \""
                            + keyshotExeList)

        return keyshotExe

    def RenderArgument(self):

        currentJob = self.GetJob()
        self.s_job_name = str(currentJob.JobName)
        self.job_id = currentJob.JobId
        self.TempCleanup()
        s_temp_render_path = self.RenderTempSetup()

        ######################################################################
        ## get plugin and job entries
        ######################################################################
        s_task_id = self.GetCurrentTaskId()

        i_version                = self.GetIntegerPluginInfoEntry("version")

        i_start_frame            = self.GetLongPluginInfoEntry("start_frame")
        i_end_frame              = self.GetLongPluginInfoEntry("end_frame")

        s_render_region          = self.GetPluginInfoEntryWithDefault("region", None)
        s_camera_name            = self.GetPluginInfoEntryWithDefault("Camera0", str())
        s_model_set_name         = self.GetPluginInfoEntryWithDefault("active_model_set", str())
        s_studio                 = self.GetPluginInfoEntryWithDefault("active_studio", str())

        self.s_scene_file_name   = self.GetPluginInfoEntryWithDefault("SceneFile", self.GetDataFilename())
        self.s_scene_file_name   = self.s_scene_file_name.replace("\\", "/")

        s_output_file_name       = self.GetPluginInfoEntry("OutputFile")
        i_output_id              = self.GetPluginInfoEntryWithDefault("output_id", "-1")
        s_output_file_name       = s_output_file_name.replace("\\", "/")
        s_temp_output            = os.path.join(s_temp_render_path, self.s_job_name)

        b_still_batch            = self.GetBooleanPluginInfoEntryWithDefault("still_batch", False)
        b_animation_batch        = self.GetBooleanPluginInfoEntryWithDefault("animation_batch", False)
        b_animation_still        = self.GetBooleanPluginInfoEntryWithDefault("animation_still", False)
        # b_single_frame           = self.GetBooleanPluginInfoEntryWithDefault("single_frame", False)
        b_multi_task_rendering   = self.GetBooleanPluginInfoEntryWithDefault("multi_task_rendering", False)
        b_multi_camera_rendering = self.GetBooleanPluginInfoEntryWithDefault("MultiCameraRendering", False)
        b_region_rendering       = self.GetBooleanPluginInfoEntryWithDefault("RegionRendering", False)
        s_render_mode            = self.GetPluginInfoEntryWithDefault("render_mode", "1")

        f_maximum_time           = self.GetFloatPluginInfoEntryWithDefault("progressive_max_time", 30)

        i_width                  = self.GetIntegerPluginInfoEntryWithDefault("render_width", 1920)
        i_height                 = self.GetIntegerPluginInfoEntryWithDefault("render_height", 1080)
        i_max_samples            = self.GetIntegerPluginInfoEntryWithDefault("progressive_max_samples", 16)

        # get custom quality options
        setAdvancedRendering       = int  (self.GetPluginInfoEntryWithDefault("advanced_samples", "16"))
        setRayBounces              = int  (self.GetPluginInfoEntryWithDefault("engine_ray_bounces", "6"))
        setAntiAliasing            = int  (self.GetPluginInfoEntryWithDefault("engine_anti_aliasing", "1"))
        setDofQuality              = int  (self.GetPluginInfoEntryWithDefault("engine_dof_quality", "3"))
        setIndirectBounces         = int  (self.GetIntegerPluginInfoEntryWithDefault("engine_indirect_bounces", "1"))
        setSharpShadows            = bool (self.GetPluginInfoEntryWithDefault("engine_sharp_shadows", "False"))
        setSharperTextureFiltering = bool (self.GetPluginInfoEntryWithDefault("engine_sharper_texture_filtering", "False"))
        setGlobalIlluminationCache = bool (self.GetPluginInfoEntryWithDefault("engine_global_illumination_cache", "False"))
        setShadowQuality           = float(self.GetPluginInfoEntryWithDefault("engine_shadow_quality", "1.0"))
        setCausticsQuality         = float(self.GetPluginInfoEntryWithDefault("engine_caustics_quality", "1.0"))
        setPixelBlur               = float(self.GetPluginInfoEntryWithDefault("engine_pixel_blur", "1.5"))
        setGlobalIllumination      = float(self.GetPluginInfoEntryWithDefault("engine_global_illumination", "1.0"))

        # get render pass options
        setOutputRenderLayers           = self.GetBooleanPluginInfoEntryWithDefault("output_render_layers", False)
        setOutputAlphaChannel           = self.GetBooleanPluginInfoEntryWithDefault("output_alpha_channel", False)
        setOutputDiffusePass            = self.GetBooleanPluginInfoEntryWithDefault("output_diffuse_pass", False)
        setOutputReflectionPass         = self.GetBooleanPluginInfoEntryWithDefault("output_reflection_pass", False)
        setOutputClownPass              = self.GetBooleanPluginInfoEntryWithDefault("output_clown_pass", False)
        setOutputDirectLightingPass     = self.GetBooleanPluginInfoEntryWithDefault("output_direct_lighting_pass", False)
        setOutputRefractionPass         = self.GetBooleanPluginInfoEntryWithDefault("output_refraction_pass", False)
        setOutputDepthPass              = self.GetBooleanPluginInfoEntryWithDefault("output_depth_pass", False)
        setOutputIndirectLightingPass   = self.GetBooleanPluginInfoEntryWithDefault("output_indirect_lighting_pass", False)
        setOutputNormalsPass            = self.GetBooleanPluginInfoEntryWithDefault("output_normals_pass", False)
        setOutputCausticsPass           = self.GetBooleanPluginInfoEntryWithDefault("output_caustics_pass", False)
        setOutputShadowPass             = self.GetBooleanPluginInfoEntryWithDefault("output_shadow_pass", False)
        setOutputAmbientOcclusionPass   = self.GetBooleanPluginInfoEntryWithDefault("output_ambient_occlusion_pass", False)

        # extract data from keys
        l_region_data            = [int(s) for s in str(s_render_region).split('"') if s.isdigit()]
        s_quality_type           = self.d_render_mode[str(s_render_mode)]

        if b_multi_camera_rendering:

            s_camera_name       = self.GetPluginInfoEntryWithDefault("Camera" + str(s_task_id), str())
            s_output_directory  = os.path.dirname(s_output_file_name)
            s_file_name, s_ext  = os.path.splitext(os.path.basename(s_output_file_name))
            s_output_file_name  = os.path.join(s_output_directory,
                                               s_camera_name,
                                               str(s_file_name + "_" + str(s_camera_name) + s_ext))

            s_output_file_name  = s_output_file_name.replace("\\", "/")
            self.LogInfo("Multitask : %s | Output path : %s" % (b_multi_camera_rendering, s_output_file_name))

        b_still_frame = i_start_frame == i_end_frame

        if i_start_frame != i_end_frame:
            # TODO : this needs testing
            i_start_frame = self.GetStartFrame()
            i_end_frame   = self.GetEndFrame()


        if b_still_batch or b_still_frame:
            self.b_output_transfer = True
            s_camera_name       = self.GetPluginInfoEntryWithDefault("camera_batch" + str(s_task_id), str())
            s_model_set_name    = self.GetPluginInfoEntryWithDefault("moldelset_batch" + str(s_task_id), str())
            s_studio            = self.GetPluginInfoEntryWithDefault("studio" + str(s_task_id), str())
            s_output_directory  = os.path.dirname(s_output_file_name)
            s_file_name, s_ext  = os.path.splitext(os.path.basename(s_output_file_name))

            if s_studio:
                add_string = s_studio
            else:
                add_string = s_camera_name + "_" + s_model_set_name

            if add_string == "_":
                add_string = "render_"
            s_output_file_name = os.path.join(s_temp_render_path, add_string, str(s_file_name + s_ext))

            self.d_transfer_data["src_path"] = os.path.dirname(s_output_file_name)
            self.d_transfer_data["out_path"] = s_output_directory

        if b_animation_batch:
            s_camera_name       = self.GetPluginInfoEntryWithDefault("active_camera", str())
            s_model_set_name    = self.GetPluginInfoEntryWithDefault("active_model_set", str())
            s_studio            = self.GetPluginInfoEntryWithDefault("active_studio", str())

        s_scene_name, s_ext = os.path.splitext(os.path.basename(self.s_scene_file_name))
        self.s_temp_scene_file_name = s_scene_name + "_{}".format(self.s_random) + "_{}".format(str(i_start_frame)) + s_ext

        # local/network/temp file operations

        s_file_name = os.path.basename(self.s_scene_file_name)
        self.s_home_path = r"C:\Temp"

        self.network_file_dir = os.path.dirname(self.s_scene_file_name)
        network_dir_name = os.path.basename(self.network_file_dir)
        self.dest_path = os.path.join(self.s_home_path, network_dir_name)
        new_scene_path = os.path.join(self.dest_path, s_file_name)
        new_scene_temp_path = os.path.join(self.dest_path, self.s_temp_scene_file_name)

        ######################################################################
        ## Constructing ENV file
        ######################################################################

        self.renderScript = os.path.join(self.GetPluginDirectory(), "KeyShot_Deadline.py")

        self.d_data_file = {
            "job_id":                           self.job_id,
            "version":                          i_version,
            "output_id":                        i_output_id,
            "DAT_SCENE_FILE_NAME":              self.s_scene_file_name,
            "DAT_TEMP_SCENE_BASE_FILE_NAME":    self.s_temp_scene_file_name,
            "new_scene_path":                   new_scene_path,
            "new_scene_temp_path":              new_scene_temp_path,
            "DAT_CAMERA":                       s_camera_name,
            "DAT_MODEL_SET":                    [s_model_set_name],
            "DAT_STUDIO":                       s_studio,
            "DAT_START_FRAME":                  i_start_frame,
            "DAT_END_FRAME":                    i_end_frame,
            "DAT_WIDTH":                        i_width,
            "DAT_HEIGHT":                       i_height,
            "DAT_OUTPUT_FILE_NAME":             s_output_file_name,
            "DAT_MAXIMUM_TIME":                 f_maximum_time,
            "DAT_PROGRESSIVE_MAX_SAMPLES":      i_max_samples,
            "DAT_QUALITY_TYPE":                 s_quality_type,  # TODO: check for "advanced mode"
            "DAT_MULTI_CAMERA_RENDERING":       b_multi_camera_rendering,
            "DAT_MULTI_TASK_RENDERING":         b_multi_task_rendering,
            "DAT_REGION_DATA":                  l_region_data,
            "setAdvancedRendering":             setAdvancedRendering,
            "setGlobalIllumination":            setGlobalIllumination,
            "setRayBounces":                    setRayBounces,
            "setPixelBlur":                     setPixelBlur,
            "setAntiAliasing":                  setAntiAliasing,
            "setDofQuality":                    setDofQuality,
            "setShadowQuality":                 setShadowQuality,
            "setCausticsQuality":               setCausticsQuality,
            "setSharpShadows":                  setSharpShadows,
            "setSharperTextureFiltering":       setSharperTextureFiltering,
            "setGlobalIlluminationCache":       setGlobalIlluminationCache,
            "setIndirectBounces":               setIndirectBounces,
            "setOutputRenderLayers":            setOutputRenderLayers,
            "setOutputAlphaChannel":            setOutputAlphaChannel,
            "setOutputDiffusePass":             setOutputDiffusePass,
            "setOutputReflectionPass":          setOutputReflectionPass,
            "setOutputClownPass":               setOutputClownPass,
            "setOutputDirectLightingPass":      setOutputDirectLightingPass,
            "setOutputRefractionPass":          setOutputRefractionPass,
            "setOutputDepthPass":               setOutputDepthPass,
            "setOutputIndirectLightingPass":    setOutputIndirectLightingPass,
            "setOutputNormalsPass":             setOutputNormalsPass,
            "setOutputCausticsPass":            setOutputCausticsPass,
            "setOutputShadowPass":              setOutputShadowPass,
            "setOutputAmbientOcclusionPass":    setOutputAmbientOcclusionPass}

        self.localize_files()

        self.LogInfo("Contents of DEADLINE_KEYSHOT_INFO file:")
        self.LogInfo(self.infoFilePath)

        with open(self.infoFilePath, 'w') as JsonData:
            json.dump(self.d_data_file, JsonData, indent=4)

        for key, value in sorted(self.d_data_file.items()):
            self.LogInfo("\t%s=%s" % (key, value))

        arguments = " -script \"%s\"" % self.renderScript

        return arguments

    def PreRenderTasks(self):
        self.LogInfo("Running PreRenderTasks")

        self.infoFilePath = os.path.join( self.GetJobsDataDirectory(), "deadline_KeyShot_info.json")
        self.progress_script=os.path.join(self.GetPluginDirectory(), "KeyShot_Still_Progress.py")
        self.SetEnvironmentVariable("DEADLINE_KEYSHOT_INFO", self.infoFilePath)
        self.SetEnvironmentVariable("PROGRESS_SCRIPT", self.progress_script)
        self.LogInfo('Setting DEADLINE_KEYSHOT_INFO environment variable to "%s"' % self.infoFilePath)

        local_python = r"C:\Python27\python.exe"
        process = subprocess.Popen('%s %s %s' % (local_python, self.progress_script, self),
                                   stdout=subprocess.PIPE,
                                   stdin=subprocess.PIPE,
                                   stderr=subprocess.PIPE,
                                   shell=True)
        output = process.communicate()[0].strip()
        print str(output)
        print ("Running progress %s : %s %s" % (process.pid,  local_python, self.progress_script))

    def PostRenderTasks(self):
        self.LogInfo("Running PostRenderTasks")
        if self.b_output_transfer:
            self.OutputTransfer(self.d_transfer_data["src_path"], self.d_transfer_data["out_path"])

    def OutputTransfer(self, src_path, out_path):

        src_path = src_path.replace("\\", "/").replace("//", "/")
        out_path = out_path.replace("\\", "/").replace("//", "/")

        self.LogInfo("Render source path : %s" % src_path)
        self.LogInfo("Render output path : %s" % out_path)

        o_package = shutil.make_archive(src_path, 'zip',
                                        os.path.dirname(src_path),
                                        os.path.basename(src_path))
        self.LogInfo("Archived package : %s" % o_package)
        net_file_path = os.path.join(out_path, os.path.basename((o_package.replace("\\", "/")))).replace("\\", "/")
        self.LogInfo("Network file path : %s" % net_file_path)
        if os.path.exists(net_file_path):
            os.remove(net_file_path)

        self.LogInfo("Moving %s to %s" % (o_package, out_path))
        shutil.move(o_package, out_path)
        self.LogInfo("Removing Directory : %s " % src_path)
        shutil.rmtree(src_path)

    def localize_files(self):
        self.LogInfo("Start Localization")

        dir_check = self.dir_update_check()
        if os.path.exists(self.dest_path) and dir_check:
            self.LogInfo('Render folder has already been transferred , returning immediately .')
            return
        elif os.path.exists(self.dest_path) and not dir_check:
            shutil.rmtree(self.dest_path)
            self.LogInfo('Render folder has been removed.')

        if self.valid_temp_folder():
            try:
                shutil.copytree(self.network_file_dir, self.dest_path)
                self.LogInfo('Render folder transferred successfully.')
            except IOError as _err:
                self.LogWarning('Render folder could not be transferred. err : %s' % _err)
        else:
            self.LogWarning('File transfer failed')

    def dir_update_check(self):

        if not os.path.exists(self.network_file_dir) or not os.path.exists(self.dest_path):
            return False

        NETWORK_FILE_DIR_LIST = os.listdir(self.network_file_dir)
        DESTINATION_PATH_LIST = os.listdir(self.dest_path)

        if len(NETWORK_FILE_DIR_LIST) == len(DESTINATION_PATH_LIST) or len(NETWORK_FILE_DIR_LIST) < len(
                DESTINATION_PATH_LIST):
            self.LogInfo('No directory update required.')
            return True
        else:
            self.LogInfo('Directory update required.')
            return False

    def valid_temp_folder(self):

        if os.path.exists(self.s_home_path):
            self.LogInfo('Temp folder has already been created.')
            return True
        else:
            try:
                os.makedirs(self.s_home_path)
                self.LogInfo('Temp folder created successfully.')
                return True
            except IOError as _err:
                self.LogWarning('Temp folder could not be created. err : %s' % _err)
                return False